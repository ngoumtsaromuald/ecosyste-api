import { ConfigService } from '@nestjs/config';
import { SearchParams, SearchResults, GeoLocation, SearchMetrics, TimePeriod, HealthStatus } from '../interfaces/search.interfaces';
import { ISearchService } from '../interfaces/search-service.interface';
import { Suggestion } from '../types/suggestion.types';
import { ElasticsearchService } from './elasticsearch.service';
import { SearchCacheService } from './search-cache.service';
import { SearchErrorHandler } from './search-error-handler.service';
import { GeocodingService } from './geocoding.service';
import { CategoryRepository } from '../../../repositories/category.repository';
import { SearchAnalyticsService } from './search-analytics.service';
import { PersonalizedSearchService } from './personalized-search.service';
import { LanguageDetectionService } from './language-detection.service';
export declare class SearchService implements ISearchService {
    private readonly elasticsearchService;
    private readonly cacheService;
    private readonly configService;
    private readonly errorHandler;
    private readonly geocodingService;
    private readonly categoryRepository;
    private readonly analyticsService;
    private readonly personalizedSearchService;
    private readonly languageDetectionService;
    private readonly logger;
    constructor(elasticsearchService: ElasticsearchService, cacheService: SearchCacheService, configService: ConfigService, errorHandler: SearchErrorHandler, geocodingService: GeocodingService, categoryRepository: CategoryRepository, analyticsService: SearchAnalyticsService, personalizedSearchService: PersonalizedSearchService, languageDetectionService: LanguageDetectionService);
    search(params: SearchParams): Promise<SearchResults>;
    suggest(query: string, limit?: number, userId?: string, language?: string): Promise<Suggestion[]>;
    searchByCategory(categoryId: string, params: SearchParams): Promise<SearchResults>;
    searchByCategoryWithHierarchy(categoryId: string, params: SearchParams): Promise<SearchResults>;
    private getAllSubcategoryIds;
    searchNearby(location: GeoLocation, radius: number, params: SearchParams): Promise<SearchResults>;
    searchByCity(city: string, params: SearchParams): Promise<SearchResults>;
    searchByRegion(region: string, params: SearchParams): Promise<SearchResults>;
    searchByAddress(address: string, radius: number, params: SearchParams): Promise<SearchResults>;
    searchNearUser(userLocation: GeoLocation, radius: number, params: SearchParams): Promise<SearchResults>;
    private searchWithAddressFallback;
    private parseAddressComponents;
    suggestWithRateLimit(query: string, limit?: number, userId?: string, sessionId?: string, language?: string): Promise<Suggestion[]>;
    private checkSuggestionRateLimit;
    getPopularSuggestions(limit?: number): Promise<Suggestion[]>;
    private transformPopularSuggestions;
    personalizedSearch(userId: string, params: SearchParams, usePersonalization?: boolean, personalizationWeight?: number): Promise<SearchResults>;
    suggestWithPopularityRanking(query: string, limit?: number, userId?: string, includePopular?: boolean, language?: string): Promise<Suggestion[]>;
    private calculateCombinedPopularityScore;
    getContextualSuggestions(query: string, userId: string, limit?: number, language?: string): Promise<Suggestion[]>;
    preloadPopularSuggestions(): Promise<void>;
    getSmartAutocompleteSuggestions(query: string, limit?: number, userId?: string, language?: string): Promise<Suggestion[]>;
    private getExactPrefixSuggestions;
    private getFuzzySuggestions;
    private deduplicateSuggestions;
    checkHealth(): Promise<HealthStatus>;
    getMetrics(period: TimePeriod): Promise<SearchMetrics>;
    private convertTimePeriodToDateRange;
    private generateCacheKey;
    private preprocessSearchParams;
    private normalizeFrenchQuery;
    private normalizeEnglishQuery;
    private normalizeMultilingualQuery;
    private correctCommonTypos;
    private expandContextualSynonyms;
    private correctEnglishTypos;
    private expandEnglishSynonyms;
    private buildTextualQuery;
    private buildElasticsearchQuery;
    private applyAdvancedFilters;
    private validateAndCleanFilters;
    private isValidGeoLocation;
    private calculateDistance;
    private toRadians;
    private buildHighlightConfig;
    private applyFilters;
    private buildSortClause;
    private addFacetAggregations;
    private transformSearchResults;
    private calculateLanguageRelevanceBoost;
    private areLanguagesCompatible;
    private isTranslationAvailable;
    changeSearchLanguage(originalParams: SearchParams, newLanguage: string, cacheKey?: string): Promise<SearchResults>;
    getAvailableLanguagesForResults(resultIds: string[]): Promise<Record<string, string[]>>;
    private transformFacets;
    private getPriceRangeLabel;
    private getPopularityLabel;
    private getRatingLabel;
    private generateSuggestionCacheKey;
    private buildAdvancedSuggestionQuery;
    private buildSuggestionQuery;
    private transformAdvancedSuggestionResults;
    private calculateSuggestionScore;
    private getResourceTypeIcon;
    private transformSuggestionResults;
    private checkIndexHealth;
    private logSearchAnalytics;
}
